# Rust Compilation Process:

## Rust Code compilation Steps:

Code generation of Rust program is done in mainly done by LLVM.
LLVM is a set of tools for building a compiler, most notable used by C++ compiler clang++.

1st Rust compiler does all that is Rust specific stuff like type and borrow checking ... and in the end it
generates a LLVM-IR. (IR = Intermediate representation ).

IR is compared to be very close to Assembly, with a bit of more higher level and platform independent. 

Next the Rust compiler calls the LLVM to convert the IR to generate machine code for the current platform
which is highly optimized. 

Next with other tools the generated machine code is wrapped into a ELF package. 

--- 

- Like C, Rust has 4 major steps that are used for compilation of the code:

1. Pre-processor: 

    Performs the basic tasks such as: 
    * Expanding macros: Replaces macro definitions with their actual code.
    * Including modules: Inserts the contents of included modules into the source code.
    * Removing comments: Deletes comments from the source code.

2. Compilation:

    Rust compiler reads the pre-processed source code and performs the following tasks:
    * Lexical analysis: Breaks the source code into individual tokens, such as keywords, identifiers,
      literals and symbols.
    * Syntax analysis: Analyzes the tokens to ensure that the code follows the Rust language syntax rules.
    * Semantic analysis: Checks the code for semantic errors, such as type errors and scoping errors.
    * Borrow checking: Checks the code for borrow errors, such as invalid references and mutable borrows.
    * Intermediate code generation: Generates intermediate code, such as LLVM IR.

3. Assembly: 

    In this step, the LLVM compiler reads the intermediate code generated by the Rust compiler and performs
    the following tasks:
    * Translates intermediate code into machine code: Converts the intermediate code into machine-specific
      code that can be executed directly by the computer.

4. Linking: 

    In this step, the linker reads the object files generated by the LLVM compiler and performs the 
    following tasks:
    * Resolves external references: Links the object files together to resolve external references, such as
      function calls and variable references.
    * Creates an executable: Combines the linked object files into a single executable file that can be run
      on the target platform.

- Rust compiler uses the LLVM compiler infrastructure, which provides a lot of the heavy lifting for the
  compilation process. 

- The Rust compiler is responsible for the front-end tasks, such as parsing and semantic analysis, while the
  LLVM compiler is responsible for the back-end tasks, such as code generation and optimization.

- As mentioned above the additional steps that the Rust compiler performs:

    1. Borrow checking: 
    The Rust compiler checks the code for borrow errors, such as invalid references and mutable borrows. 
    This ensures that the code is memory-safe and prevents common errors like null pointer dereferences and
    data races.

    2. Type checking: 
    The Rust compiler checks the code for type errors, such as mismatched types and invalid type
    conversions. This ensures that the code is type-safe and prevents errors like type mismatches and
    incorrect function calls.

    3. Lifetime checking: 
    The Rust compiler checks the code for lifetime errors, such as references that outlive their referents.
    This ensures that the code is memory-safe and prevents errors like dangling pointers.

    4. Ownership checking: 
    The Rust compiler checks the code for ownership errors, such as multiple owners of the same data. This
    ensures that the code is memory-safe and prevents errors like data corruption and crashes.

    5. Pattern matching checking: 
    The Rust compiler checks the code for pattern matching errors, such as non-exhaustive patterns and
    overlapping patterns. This ensures that the code is correct and prevents errors like unexpected behavior
    and crashes.

    6. Const evaluation: 
    The Rust compiler evaluates constant expressions and checks that they are valid. This ensures that the
    code is correct and prevents errors like invalid constant values.

    7. Linting:
    The Rust compiler checks the code for common errors and warnings, such as unused variables and
    unreachable code. This helps to improve the quality and maintainability of the code.

    8. Dead code elimination: 
    The Rust compiler removes dead code, such as unreachable branches and unused functions. This helps to
    improve the performance and size of the compiled code.

    9. Optimization: 
    The Rust compiler performs various optimizations, such as inlining and loop unrolling, to improve the
    performance of the compiled code.

    10. MIR (Mid-Level Intermediate Representation) generation: 
    The Rust compiler generates MIR, which is a platform-agnostic intermediate representation of the code. 
    This allows the compiler to perform additional optimizations and checks before generating machine code.

    11. MIR optimization: 
    The Rust compiler optimizes the MIR code to improve performance and reduce code size.

    12. LLVM IR (Intermediate Representation) generation: 
    The Rust compiler generates LLVM IR, which is a platform-specific intermediate representation of the
    code. This allows the compiler to generate machine code for the target platform.

    13. LLVM IR optimization: 
    The Rust compiler optimizes the LLVM IR code to improve performance and reduce code size.

    14. Code generation: The Rust compiler generates machine code for the target platform.

    15. Debugging information generation: 
    The Rust compiler generates debugging information, such as DWARF and PDB files, to help with debugging 
    and profiling.

    The above are steps that the Rust compiler performs to ensure that the code is correct, efficient, and
    safe.

## Rust compiler 

Rust Compiler steps:

The Rust compiler, also known as `rustc`, performs the following steps during the compilation process:

    1. Lexical Analysis: 
    The compiler reads the source code and breaks it down into individual tokens, such as keywords,
    identifiers, literals, and symbols.

    2. Syntax Analysis: 
    The compiler analyzes the tokens to ensure that the code follows the Rust language syntax rules. 
    This step checks for syntax errors, such as mismatched brackets or incorrect use of keywords.

    3.Semantic Analysis: 
    The compiler checks the code for semantic errors, such as type errors, borrow checker errors, and other
    logical errors. This step ensures that the code is correct and makes sense.

    4. Name Resolution: 
    The compiler resolves the names of variables, functions, and other identifiers to their corresponding
    definitions.

    5. Type Checking: 
    The compiler checks the types of variables, function parameters, and return types to ensure that they
    match the expected types.

    6. Borrow Checking: 
    The compiler checks the borrow rules to ensure that references are valid and do not outlive their
    referents.

    7. MIR Generation: 
    The compiler generates the Mid-Level Intermediate Representation (MIR) of the code, which is a
    platform-agnostic representation of the code.

    8. MIR Optimization: 
    The compiler optimizes the MIR code to improve performance and reduce code size.

    9. LLVM IR Generation: 
    The compiler generates the LLVM Intermediate Representation (IR) of the code, which is a
    platform-specific representation of the code.

    10. LLVM IR Optimization: 
    The compiler optimizes the LLVM IR code to improve performance and reduce code size.

    11. Code Generation: 
    The compiler generates the final machine code for the target platform.

    12. Linking: 
    The compiler links the generated machine code with the Rust standard library and other dependencies to
    create the final executable.

