# V4L2: Part 1

- Linux SubSystems.
- Linux Device SubSystem (Device Model, Device Instance, Device Registration ( device drivers )).
- Linux V4L2 sub-system.
- V4L2 M2M sub-system.
- V4L2 Decoder.
- V4L2 Encoder.

## - Linux SubSystems:

Linux kernel core and kernel framework is the central part of the kernel kernel that is provides the 
infrastructure for the sub-system and drivers to work.

i.e the Kernel core is responsible for managing the interaction between the sub-system and the drivers,
providing services such as :

1. Process Management:
    Manage processes, threads, and scheduling.

2. Memory Managerment;
    Manage physical and virtual memory, includubg 

3. Interrupt handling: 
    handling interrupts generated by HW devices.

4. Device Managemen:
    Managing device driver and providing framework for device interaction.

5. Filesystem Management:
    Managing file system, including file access, storage and retrival.

6. Networking:
    Managing netowrk device, protocols and socket operations.

7. Security:
    enforcing security policies, such as access control, authentication and authorization.

Kernel Core provides APIs and data structures that allow sub-systems and drivers to interact with 
each other and with the kernel.

The API's include:

1. System calls:
    a set of interfaces that allow user-space apps to request kernel services.

2. Kernel API's:
    a set of interfaces that allow sub-systems and drivers to interact with the kernel.

3. Device Model:
    a framework for managing device drivers and devices.

Some of the key components of the Kernel Core include:

1. **System Call Interface** (syscall.c):
    handles system calls from user-space applications.
2. **Process Scheduler** (schedule.c): 
    manages process scheduling and context switching.
3. **Memory Manager** (mm/): 
    manages physical and virtual memory.
4. **Interrupt Handler** (irq/): 
    handles interrupts generated by hardware devices.
5. **Device Manager** (drivers/): 
    manages device drivers and provides a framework for device interaction.
6. **Filesystem Manager** (fs/): 
    manages file systems and provides a framework for file access.

The Kernel Core is responsible for orchestrating the interactions between these components and 
providing a stable and efficient platform for the sub-systems and drivers to operate on.

- __platform_driver_register and platform_device_register:

In the Linux kernel, both `__platform_driver_register` and `platform_device_register` are used to 
register platform devices and drivers, but they serve different purposes and are used in different contexts.

**`__platform_driver_register(struct platform_driver *drv, struct module *owner)`**

This function registers a platform driver with the kernel. 

A platform driver is a driver that manages a specific platform device, such as a serial port, 
a GPIO controller, or a clock generator. 
The `__platform_driver_register` function is used to register the driver with the kernel, so that it 
can be matched with a platform device.

The `struct platform_driver` structure contains information about the driver, such as its name, 
the devices it supports, and the probe and remove functions that will be called when a device is bound 
to the driver.

The `owner` parameter specifies the module that owns the driver. 
This is typically the module that contains the driver code.

**`platform_device_register(struct platform_device *pdev)`**

This function registers a platform device with the kernel. 

A platform device is a device that is specific to a particular platform, such as a SoC (System-on-Chip) 
or a motherboard. 
The `platform_device_register` function is used to register a platform device with the kernel, so that 
it can be matched with a platform driver.

The `struct platform_device` structure contains information about the device, such as its name, 
the resources it requires (e.g., I/O memory, interrupts), and the driver that will manage it.

Recap:
    - `__platform_driver_register()`:
        Register a platform driver and the kernel, so it can be matched with a platform device.
    - `platform_device_register`:   
        Register a platform device with the kernel, so it can be matched with a platform dirver.
    - The kernel matches the platform device with the platform driver based on the device;s name and 
    the driver'ssupported devices.
    - the kernel calls the drivers's probe function to bind the device to the driver.

## - Device Model, Device Instances and Device registration.

- Device: In context of Linux kernel, it refers to a physical or virtual hardware component that provides a
  specific functionality, such as:
  * A physical device like a hard drive, network interface or webcam.
  * A virtual device, like software-based network interce or a psudo-random number generator.

- A device is typically represented by a **device node** in the /sys directory, which provides information
about the device such as its name, type, and capabilities.

- Device Instance: is a SW representation of a specific device that is connected to the system.
It's an instance of a device, which its own set of attributes such as:
* A specific device identifier (e.g: a bus address or device number).
* A set of device-specific settings or configurations.
* A reference to the device driver that manages the device.

=> device instance is a specific occurance of a device, with its own unique characteristics and settings.

## - Relationship between device and device instance:

- One device, multiple instances: A single device can have multiple instances, each with its own unique
  characteristics and settings. Ex: A system with multiple USB cameras would have one device ( the USB
  camera device ) with multiple instance ( each camera connected to the system. )
  Or a system with more then one network interface.

- One instance, one device: each device instance is associated with a single device.

To illustrate this relationship, consider the following example:

* Device: `usb_camera` (a USB camera device)
* Device instances:
        + `usb_camera0` (instance 0, representing a specific USB camera connected to the system)
        + `usb_camera1` (instance 1, representing another USB camera connected to the system)

In this example, the `usb_camera` device has two instances: 
    `usb_camera0` and `usb_camera1`. 

Each instance represents a specific USB camera connected to the system, with its own unique settings and
characteristics.

When a device driver registers a device instance using `v4l2_device_register()` (or a similar function), 
it creates a new device instance in the kernel, which is associated with a specific device. 

The device instance is then used to manage the device and provide access to its functionality.

- A device instance represents a single device, such as a webcam, a network interface card, or a 
hard drive, that is managed by a device driver.

A device instance is a software representation of a physical device, and it contains information about 
the device, such as:

1. **Device identifier**: A unique identifier for the device, such as a bus address or a device number.
2. **Device type**: The type of device, such as a camera, network interface, or storage device.
3. **Device capabilities**: The capabilities of the device, such as the resolution of a camera or the 
speed of a network interface.
4. **Device configuration**: The current configuration of the device, such as the settings for a camera or 
the IP address of a network interface.
5. **Device state**: The current state of the device, such as whether it is enabled or disabled.

A device instance is typically represented by a data structure in the kernel, 
such as a `struct device` or a `struct v4l2_device` 

##  - V4L2 devices registration:

This data structure contains pointers to functions that implement the device's operations, 
such as open, close, read, and write.

In the context of the `v4l2_device_register()` function, the device instance is the `struct v4l2_device` 
structure that is passed as an argument to the function. 

This structure represents a specific instance of a V4L2 device, such as a webcam or a TV tuner, and it 
contains information about the device, such as its name, type, and capabilities.

When you register a device instance with the V4L2 subsystem using `v4l2_device_register()`, you are 
creating a new device instance in the kernel, which represents a specific device that is connected to 
the system.

**Registration process**

Here's what happens during the registration process:

1. **Device allocation**:  The V4L2 subsystem allocates a new device instance and initializes its 
internal data structures.

2. **Device registration**: 
The `v4l2_device_register()` function registers the device instance with the V4L2 framework. 
This involves adding the device to the V4L2 device list and creating a new file in the `/dev` directory 
(e.g., `/dev/video0`) that represents the device.

3. **Device initialization**: 
The V4L2 subsystem initializes the device instance by calling the `open()` function of the device driver. 
This allows the driver to perform any necessary initialization, such as allocating resources or setting up 
the device.

4. **Device notification**: 
The V4L2 subsystem notifies other kernel components, such as the device manager, about the new device 
instance.

**What happens after registration**

After the device instance is registered, the following events occur:

1. **Device file creation**: 
    A new file is created in the `/dev` directory, which represents the device. 
    This file is used by user-space applications to access the device.

2. **Device node creation**: 
    A new device node is created in the `/sys` directory, which provides information about the device, 
    such as its name, type, and capabilities.

3. **Device driver binding**: 
    The device driver is bound to the device instance, allowing the driver to manage the device and 
    handle I/O operations.

4. **Device availability**: 
    The device is now available for use by user-space applications, which can open the device file and 
    perform I/O operations using the V4L2 API.

**Other device registration functions**

While `v4l2_device_register()` is specific to the V4L2 subsystem, there are similar registration functions 
for other device types, such as:

* `usb_register_device()` for USB devices
* `pci_register_device()` for PCI devices
* `platform_device_register()` for platform devices
* `input_register_device()` for input devices (e.g., keyboards, mice)

These functions follow a similar pattern, registering the device instance with the respective subsystem 
and performing the necessary initialization and notification steps.

## - V4L2 Device Driver:

**1. Representing the device as a "device instance"**:

* A device driver represents the HW or pseudo device as a "device instance" by creating a struct that 
contains information about the device, such as its name, type, and capabilities.

* The struct is typically associated with a specific subsystem of the kernel, such as V4L2 for 
video devices or USB for USB devices.

* The device instance struct often contains function pointers to the driver's implementation of various 
operations, such as open, close, read, and write.

**2. Registering the device with the kernel**:

* The device driver registers the device instance with the kernel using a registration function specific 
to the subsystem, such as `v4l2_device_register()` or `usb_register_device()`.

* This registration process adds the device instance to the kernel's internal data structures, making it 
visible to the system.

* The kernel creates a device node in the `/sys` directory, which provides information about the device, 
such as its name, type, and capabilities.

Note: for device related profiling /sys directory is the place holder.

**3. Device driver initialization**: 

The device driver is responsible for initializing the device instance, which includes allocating resources,
setting up the device, and preparing it for use.

**4. Controlling and managing I/O operations**:

* The device driver is responsible for controlling and managing I/O operations associated with the device.
* This includes handling requests from user-space applications, such as read and write operations, and 
performing the necessary actions to interact with the hardware or pseudo device.
* The driver may also need to handle interrupts, DMA transfers, and other low-level details related to 
I/O operations.

**5. Facilitating access to resources or functionality**:

* The device driver provides a way for user-space applications to access the device's resources or 
functionality using kernel-defined IPC mechanisms, such as:
        + `/proc/` filesystem: provides a way to access device-specific information and configuration options.
        + Netlink: a socket-based IPC mechanism for communication between user-space and kernel-space.
        + Ioctls: a set of ioctl commands that allow user-space applications to control and configure the device.
        + Shared memory: a mechanism for sharing memory between user-space and kernel-space.

Some more additional points to consider:

* **Device driver cleanup**: When the device is removed or the system is shut down, the device driver is 
responsible for cleaning up resources, releasing memory, and performing any necessary shutdown operations.

* **Error handling**: Device drivers must handle errors and exceptions that occur during I/O operations, 
such as device failures, timeouts, or invalid requests.

* **Power management**: Device drivers may need to manage power consumption and implement power-saving 
features, such as suspend and resume operations.

* **Security**: Device drivers must ensure that access to the device is secure and follows the principles 
of least privilege, to prevent unauthorized access or malicious behavior.

Linux kernel device driver plays a crucial role in managing a device and providing access to its resources 
and functionality to user-space applications.

# V4L2 SubSystem 


## - V4L2:

The Linux kernel's V4L2 (Video for Linux 2) subsystem is a set of APIs and drivers that provide a 
standardized way for applications to access and control video capture devices, such as webcams, 
TV tuners, and video encoders.

The V4L2 subsystem is responsible for managing the interaction between the kernel and user-space 
applications that want to capture or output video streams.

    [ Applications ] <==> [ /dev/videoX ] <==> [V4L2 Layer] <==> [ V4L2 kernel driver ]


V4L2 - set of APIs and standards for handling video devices on Linux. 
- Video devices could be camera sensors providing streams, video encoder , video decoder and apart from 
these there could be analog radio and any output drivers as device. 
- These v4l2 devices are char type device and each devices get represented by its names in the /dev
tree like /dev/video. If there are multiple devices or video related data, streams then there can be 
multiple video device names like /dev/video0 , /dev/video1 , basically /dev/videoX. 

- Since it provides set of APIs to handle these devices which lies in physical memory region of the 
system and get juice from kernel. 

- V4L2 gets integrated with media framework and resides in kernel as v4l2 driver ( this helps to integrate 
the device/sub-device kernel driver with the media framework. )

- V4L2 API includes a very long list of driver callbacks to respond to the many ioctl() commands made 
available to user space.

User Space:                            [ Open (/dev/videoX)]
----------------------------------------------|------------------------------------------
Kernel                                        |
                                              |
                                              v
                  video_device.cdev.fops= v4l2_file_ops  -> video_device[0]=vdev0,video_device[1]=vdev1
                                              |
                                              |
                                              v 
                 struct v4l2_subdev < ------vdev->fops ------------+
                    |                           |videoioc_dqbuf    |
                                                v                  |
                                            dqueue_list         queue_list
                                                |                  |
                                                v                  v
                                              buffer1            buffer1
                                                |                  |
                                                v                  v
                                              buffer2            buffer2
                                                |                  |
                                                v                  v
                                              bufferN            bufferN
                                                 |                  |
                                                 |                  |
                                 save data       v                  v get buffer
                                 put buffer  +-------------------------+
                                 to the list | data processing module  |
                                             +-------------------------+



Kernel Side V4L2 Operations : -
a) Opening V4L2 device using v4l2_open()
b) Controlling V4L2 device using v4l2_ioctl()
c) Reading from V4L2 device using v4l2_read()
d) Writing onto V4L2 device using v4l2_write()
e) Polling onto V4L2 device using v4l2_poll()
f) Mmaping v4L2 device using v4l2_mmap()
g) Closing V4L2 device using v4l2_release()

for ex:
    ``` fd = open("/dev/video0", O_RDWR);
        close(fd)
    ```

V4L2 ioctl : 
    a)VIDIOC_S_FORMAT
    b)VIDIOC_S_CTRL
    c)VIDIOC_REQBUFS
    d)VIDIOC_QUERYBUF 
    e)VIDIOC_QBUF 
    f)VIDIOC_STREAMON 
    g)VIDIOC_DQBUF 
    h)VIDIOC_STREAMOFF

- [Application] 
   -> [Open device /dev/video0]
     -> [VIDEO_QUERYCAP]
       -> [VIDIOC_S_INPUT]
         -> [VIDIOC_REQBUF]
           -> [VIDIOC_QBUF]
             -> [VIDIOC_QUERYBUF]
               -> [VIDEO_STREAMON]

## Video Buffer:

V4L2 has a video buffer layer which acts as medium between V4L2 driver and app( user-space side).
There is a video device that will be streaming data (video frames) into video buffers (vb).

=> This will require to implement calls like buffer allocation, queuing, de-queuing, streaming I/O and 
other streaming controls like start/stop.

more in detail: kernel documentation:

    https://www.kernel.org/doc/Documentation/video4linux/videobuf

Ref: above content:  More @ http://technoflinger.blogspot.com/2013/06/v4l2-tutorial.html

Here's an overview of the V4L2 subsystem and its components:

## - Components:

1. **V4L2 Core**: 

- The V4L2 core is the central component of the V4L2 subsystem. 
- It provides a set of APIs that allow user-space applications to interact with video devices. 
- V4L2 core is responsible for managing the video device's resources, such as buffers,formats, & controls.

2. **Video Device Drivers**: 

- Video device drivers are kernel modules that implement the V4L2 API for specific video devices. 
- These drivers are responsible for controlling the HW and providing the necessary functionality to the 
  V4L2 core.

3. **Video Buffers**: 

- Video buffers are memory regions used to store video data. 
- The V4L2 core manages the allocation and deallocation of video buffers, which are then used by the 
  video device drivers to capture or output video streams.

4. **Video Formats**: 

- Video formats define the structure and layout of the video data stored in video buffers. 
- The V4L2 core provides a set of standard video formats, such as YUV, RGB, and MJPEG, which can be 
  used by video device drivers and user-space apps.

5. **Controls**: 

- Controls are used to configure and adjust various aspects of the video device, such as brightness, 
contrast, and gain. 
The V4L2 core provides a set of standard controls that can be used by user-space applications to adjust 
the video device's settings.


## - APIs:

The V4L2 API provides a set of ioctl() calls that allow user-space applications to interact with the 
V4L2 core and video device drivers. 

Some of the key APIs include:

1. **VIDIOC_QUERYCAP**: Retrieves information about the video device's capabilities.
2. **VIDIOC_S_FMT**: Sets the video format and buffer size for the video device.
3. **VIDIOC_REQBUFS**: Requests video buffers from the V4L2 core.
4. **VIDIOC_QBUF**: Queues a video buffer for capture or output.
5. **VIDIOC_DQBUF**: Dequeues a video buffer after capture or output.
6. **VIDIOC_STREAMON**: Starts or stops the video stream.
7. **VIDIOC_G_CTRL**: Gets the value of a control.
8. **VIDIOC_S_CTRL**: Sets the value of a control.

## - User-Space Applications:


- User-space applications, such as video capture tools, media players, and video conferencing software,
use the V4L2 API to interact with the V4L2 core and video device drivers. 
These applications can capture video streams, adjust video settings, and control the video device's 
behavior using the V4L2 API.

## - Benefits:

The V4L2 subsystem provides several benefits, including:

1. **Standardization**: 

V4L2 provides a standardized API for video capture devices, making it easier for developers to write 
applications that work with multiple devices.

2. **Portability**: 

V4L2 allows video device drivers to be written in a way that is independent of the underlying hardware, 
making it easier to port drivers to different platforms.

3. **Flexibility**: 

V4L2 provides a flexible framework that allows developers to implement custom video formats, controls, 
and features.

In summary, the V4L2 subsystem is a critical component of the Linux kernel that provides a standardized 
way for applications to access and control video capture devices. 

Its components, including the V4L2 core, video device drivers, video buffers, video formats, and controls,
work together to provide a flexible and portable framework for video capture and output.

## - V4L2 Core:

The V4L2 core is the central component of the V4L2 subsystem, responsible for managing the interaction 
between user-space applications and video device drivers. 

It provides a set of APIs that allow user-space applications to access and control video capture devices, 
and it manages the resources and functionality of the video device drivers.

**Architecture:**

The V4L2 core is implemented as a kernel module, which is loaded into the Linux kernel. 
It consists of several components, including:

1. **v4l2_device**: 
This is the main structure that represents a V4L2 device. It contains information about the device, 
such as its name, type, and capabilities.

2. **v4l2_ioctl_ops**: 
This structure defines the ioctl() operations that can be performed on a V4L2 device. 
It includes functions for handling ioctl() calls, such as VIDIOC_QUERYCAP and VIDIOC_S_FMT.

3. **v4l2_file_operations**: 
This structure defines the file operations that can be performed on a V4L2 device, such as open(), close(),
and ioctl().

4. **v4l2_buffer**: 
This structure represents a video buffer, which is a region of memory used to store video data.

**Functionality:**

The V4L2 core provides several key functionalities, including:

1. **Device Management**: 
The V4L2 core manages the lifetime of V4L2 devices, including device registration, deregistration, and 
hotplug events.

2. **Resource Management**: 
The V4L2 core manages the resources required by video device drivers, such as memory, interrupts, and 
DMA channels.

3. **Buffer Management**: 
The V4L2 core manages the allocation and deallocation of video buffers, which are used to store video data.

4. **Format Management**: 
The V4L2 core manages the video formats supported by the video device, including the format of the 
video data stored in video buffers.

5. **Control Management**: 
The V4L2 core manages the controls supported by the video device, such as brightness, contrast, and gain.

6. **ioctl() Handling**: 
The V4L2 core handles ioctl() calls from user-space applications, including VIDIOC_QUERYCAP, VIDIOC_S_FMT, 
and VIDIOC_REQBUFS.

7. **Video Streaming**: 
The V4L2 core manages the video streaming process, including the queuing and dequeuing of video buffers.



**Key Data Structures:**

The V4L2 core uses several key data structures to manage video devices and buffers, including:

1. **v4l2_device**: 
This structure represents a V4L2 device and contains information about the device, such as its name, type, 
and capabilities.

2. **v4l2_buffer**: 
This structure represents a video buffer and contains information about the buffer, such as its size, 
format, and flags.

3. **v4l2_format**: 
This structure represents a video format and contains information about the format, such as its type, 
width, and height.

4. **v4l2_control**: 
This structure represents a control and contains information about the control, such as its type, value, 
and flags.

**Key Functions:**

The V4L2 core provides several key functions that are used by video device drivers and user-space 
applications, including:

1. **v4l2_device_register()**: 
Registers a V4L2 device with the V4L2 core.

2. **v4l2_device_unregister()**: 
Unregisters a V4L2 device from the V4L2 core.

3. **v4l2_ioctl()**: 
Handles ioctl() calls from user-space applications.

4. **v4l2_buf_init()**: 
Initializes a video buffer.

5. **v4l2_buf_prepare()**: 
Prepares a video buffer for capture or output.

6. **v4l2_buf_queue()**: 
Queues a video buffer for capture or output.

7. **v4l2_buf_dequeue()**: 
Dequeues a video buffer after capture or output.


**Benefits:**

The V4L2 core provides several benefits, including:

1. **Standardization**: 
The V4L2 core provides a standardized API for video capture devices, making it easier for developers to
write applications that work with multiple devices.

2. **Portability**: 
V4L2 core allows video device drivers to be written in a way that is independent of the underlying 
hardware, making it easier to port drivers to different platforms.

3. **Flexibility**: 
The V4L2 core provides a flexible framework that allows developers to implement custom video formats,
controls, and features.

4. **Efficiency**: 
The V4L2 core provides an efficient way to manage video devices and buffers, reducing the overhead of 
video capture and output operations.

---
M2M device:

- V4L2 core also handles Memory-to-Memory (M2M) devices.

- M2M devices are a type of video device that performs video processing operations, such as encoding,
decoding, and transcoding, without capturing or outputting video data to/from external devices. 

Instead, they process video data in memory, hence the name "Memory-to-Memory".

The V4L2 core provides support for M2M devices through the `v4l2_m2m` module, which is a part of the 
V4L2 core. 
This module provides a set of APIs and data structures that allow M2M devices to be managed and controlled
by the V4L2 core.

Here are some key aspects of M2M device support in the V4L2 core:

**M2M Device Registration**:

M2M devices register with the V4L2 core using the `v4l2_m2m_device_register()` function, which is similar
to the `v4l2_device_register()` function used by capture devices.

The registration process involves providing information about the M2M device, such as its capabilities, 
formats, and controls.

**M2M Buffer Management**:

M2M devices use the same buffer management API as capture devices, with some modifications to accommodate 
the M2M use case. 
The `v4l2_m2m_buffer` structure is used to represent an M2M buffer, which is a region of memory used to
store video data.

**M2M IOCTLs**:

The V4L2 core provides a set of M2M-specific ioctl() calls, such as `VIDIOC_M2M_STREAMON` and
`VIDIOC_M2M_STREAMOFF`, which allow user-space applications to control the M2M device's streaming state.

**M2M Queue Management**:

M2M devices use a queue-based approach to manage the processing of video data. 
The V4L2 core provides APIs for queueing and dequeuing buffers, as well as for managing the queue's state.

**M2M Device Controls**:

M2M devices can have controls, such as bitrate, framerate, and quality, which can be adjusted by user-space
applications using the V4L2 core's control API.

The V4L2 core's support for M2M devices provides a flexible and standardized way for developers to 
implement video processing pipelines using M2M devices. This allows for more efficient and scalable
video processing, as well as easier integration with other V4L2 devices and applications.

Some examples of M2M devices that can be supported by the V4L2 core include:

* Video encoders (e.g., H.264, VP9)
* Video decoders (e.g., H.264, VP9)
* Transcoders (e.g., H.264 to VP9)
* Image processing units (e.g., scaling, cropping, filtering)

By supporting M2M devices, the V4L2 core provides a more comprehensive framework for video processing 
and manipulation in Linux.
