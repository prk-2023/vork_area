# Stage 5: Advanced Linux Device Model Topics

---

## 5.1 What this stage covers:

* **Power management in-depth:** runtime PM, system suspend, wakeup handling
* **Device driver model internals:** device and driver structs deep dive
* **Advanced sysfs and kobject manipulation**
* **Reference counting and lifetime management**
* **Dynamic device creation/removal and hotplugging mechanisms**
* **Multi-function devices and function drivers**
* **Device model locking and concurrency**
* **Using debugfs and tracing tools to troubleshoot device model issues**

---

### 5.1.1 Power Management (PM)

* **Runtime PM:** Allows devices to suspend/resume individually when idle.
* **System PM:** Suspend/resume entire system; devices coordinate through PM callbacks.
* Implemented via `.runtime_suspend()`, `.runtime_resume()`, `.suspend()`, `.resume()` callbacks in the driver.
* Use `pm_runtime_enable()`, `pm_runtime_get_sync()`, `pm_runtime_put()` APIs for runtime PM.

---

### 5.1.2 Device and Driver Struct Internals

* Understanding `struct device`, `struct device_driver`, `struct bus_type`.
* Their fields, especially kobjects, reference counts, and power management data.
* How these structs link together to implement device model functionality.

---

### 5.1.3 Advanced Sysfs & Kobject Usage

* Creating nested sysfs groups and attributes.
* Custom kobjects vs device kobjects.
* Adding/removing sysfs attributes dynamically.

---

### 5.1.4 Reference Counting & Lifetime

* `get_device()`, `put_device()`, `kobject_get()`, `kobject_put()`.
* Avoiding memory leaks and use-after-free bugs.
* Proper device and driver ownership management.

---

### 5.1.5 Dynamic Device Creation & Hotplugging

* Using `device_register()`, `device_add()`, `device_unregister()`.
* Hotplug events and uevent emission.
* Creating devices for hardware discovered at runtime.

---

### 5.1.6 Multi-function Devices

* Devices exposing multiple interfaces/functions.
* How device model manages multiple function drivers for a single physical device.

---

### 5.1.7 Device Model Locking and Concurrency

* Spinlocks, mutexes protecting device model structures.
* When and how to use locking in device drivers.

---

### 5.1.8 Debugging Device Model

* Using `debugfs` entries like `/sys/kernel/debug/devices`.
* `udevadm monitor`, `udevadm info` for runtime device info.
* Kernel dynamic debug, tracepoints, and ftrace for tracing device events.

---

### topics

* **Deep dive into runtime PM with a sample driver?**
* **Explore multi-function devices with example?**
* **Walkthrough of reference counting and safe device removal?**
* **Example of advanced sysfs attribute management?**
* **Showcase debugging device model with debugfs and tracing?**

---

Perfect! Let’s start with the first topic:

---

## 5.2 Power Management (PM) Deep Dive

---
* Power management helps reduce power consumption by suspending devices when not in use and resuming them

---

### 5.2.1 Power Management (PM) Deep Dive: Runtime PM and System Suspend

---

### 5.2.2 Overview

* **Runtime PM**: Suspend/resume individual devices dynamically based on usage.
* **System PM**: Suspend/resume the whole system, with coordinated device callbacks.
* Helps save power by turning off devices when idle.

---

### 5.2.3 Key Driver Callbacks for Power Management

| Callback                | Description                             |
| ----------------------- | --------------------------------------- |
| `.runtime_suspend()`    | Called to suspend device during runtime |
| `.runtime_resume()`     | Called to resume device during runtime  |
| `.suspend()`            | Called during system suspend            |
| `.resume()`             | Called during system resume             |
| `.freeze()` / `.thaw()` | Called during hibernation freeze/thaw   |

---

### 5.2.4 Enabling Runtime PM in Driver

```c
static int mydrv_probe(struct platform_device *pdev)
{
    ...
    pm_runtime_enable(&pdev->dev); // Enable runtime PM for device
    pm_runtime_get_sync(&pdev->dev); // Bring device to active state
    ...
    return 0;
}

static int mydrv_remove(struct platform_device *pdev)
{
    ...
    pm_runtime_disable(&pdev->dev);
    return 0;
}
```

---

### 5.2.5 Implementing Runtime PM Callbacks

```c
static int mydrv_runtime_suspend(struct device *dev)
{
    printk(KERN_INFO "Device runtime suspend\n");
    // Put device hardware into low-power mode here
    return 0;
}

static int mydrv_runtime_resume(struct device *dev)
{
    printk(KERN_INFO "Device runtime resume\n");
    // Reactivate device hardware here
    return 0;
}

static const struct dev_pm_ops mydrv_pm_ops = {
    .runtime_suspend = mydrv_runtime_suspend,
    .runtime_resume = mydrv_runtime_resume,
    // Optional: .suspend and .resume for system suspend
};

static struct platform_driver mydrv = {
    .probe = mydrv_probe,
    .remove = mydrv_remove,
    .driver = {
        .name = "mydriver",
        .pm = &mydrv_pm_ops,
    },
};
```

---

### 5.2.6 Using Runtime PM APIs in Client Code

```c
pm_runtime_get_sync(dev);  // Resume device and increment usage count
pm_runtime_put(dev);       // Decrement usage count, may suspend device if idle
```

---

### 5.2.7 System Suspend Example (Optional)

```c
static int mydrv_suspend(struct device *dev)
{
    printk(KERN_INFO "System suspend\n");
    // Prepare device for system suspend
    return 0;
}

static int mydrv_resume(struct device *dev)
{
    printk(KERN_INFO "System resume\n");
    // Restore device state
    return 0;
}
```

---

### 5.2.8 Summary

* Runtime PM lets you save power by suspending devices individually.
* Implement `runtime_suspend` and `runtime_resume` callbacks.
* Use `pm_runtime_enable()`, `pm_runtime_get_sync()`, and `pm_runtime_put()` to manage device state.
* System PM callbacks are optional and handle suspend/resume for the whole system.

---

Would you like me to:

* Move on to **6.2 Device and Driver Struct Internals**?

## 5.3 Device and Driver Struct Internals

---

The Linux device model revolves around two core structures:

* `struct device`
* `struct device_driver`

They are deeply tied to the **bus**, **driver binding**, **sysfs**, and **power management** systems.

---

### 5.3.1 `struct device` – Represents a Device

Declared in `include/linux/device.h`:

```c
struct device {
    struct device           *parent;
    struct device_private   *p;
    struct kobject          kobj;
    const char              *init_name;
    struct bus_type         *bus;
    struct device_driver    *driver;
    void                    *driver_data;
    void                    *platform_data;
    struct dev_pm_info      power;
    ...
};
```

---

### 5.3.2 Key Fields in `struct device`

| Field           | Purpose                                                         |
| --------------- | --------------------------------------------------------------- |
| `parent`        | Pointer to parent device (for hierarchy)                        |
| `kobj`          | Kernel object for sysfs integration                             |
| `bus`           | Bus type the device is on (platform, PCI, I2C, etc.)            |
| `driver`        | Pointer to the bound driver                                     |
| `driver_data`   | Private data set by driver (via `dev_set_drvdata()`)            |
| `platform_data` | Used in board files for static data (deprecated in favor of DT) |
| `power`         | Power management info (`runtime_pm`, etc.)                      |

---

### 5.3.3 `struct device_driver` – Represents a Driver

Also in `include/linux/device.h`:

```c
struct device_driver {
    const char          *name;
    struct bus_type     *bus;
    struct module       *owner;
    const struct of_device_id *of_match_table;
    int (*probe)        (struct device *dev);
    int (*remove)       (struct device *dev);
    struct dev_pm_ops   *pm;
    ...
};
```

---

### 5.3.4 Key Fields in `struct device_driver`

| Field            | Purpose                                         |
| ---------------- | ----------------------------------------------- |
| `name`           | Driver name (used for matching)                 |
| `bus`            | Bus it belongs to (must match device's bus)     |
| `owner`          | Module that owns the driver (`THIS_MODULE`)     |
| `of_match_table` | Device Tree matching table                      |
| `probe`          | Called when driver is matched to a device       |
| `remove`         | Called when driver is unbound or device removed |
| `pm`             | Pointer to power management callbacks           |

---

### 5.3.5 Binding Flow Summary

1. A device is created (`device_add()`) and assigned a `bus`.
2. The bus’s `.match()` function checks available drivers on that bus.
3. If match succeeds, the driver’s `.probe()` function is called.
4. The driver is stored in `dev->driver`.
5. Driver can store per-device state with `dev_set_drvdata()`.

---

### 5.3.6 Device Model Tree

* Devices are organized as a tree using the `.parent` field.
* `kobject` links allow device entries in `/sys/devices/...`.

Example layout in memory:

```
[Device A] (parent = NULL)
   └── [Device B] (parent = A)
         └── [Device C] (parent = B)
```

And in sysfs:

```
/sys/devices/deviceA/
/sys/devices/deviceA/deviceB/
/sys/devices/deviceA/deviceB/deviceC/
```

---

### 5.3.7 Sysfs Integration

* Every `struct device` creates a sysfs directory.
* Drivers can add files using `device_create_file()`, or define `dev_attr_*`.
* All device-driver-bus relationships are exposed in `/sys`.

---

### 5.3.9 Common APIs

```c
dev_set_drvdata(dev, data);  // Store driver data
data = dev_get_drvdata(dev); // Retrieve it

get_device(dev);             // Increase refcount
put_device(dev);             // Decrease refcount
```

---

### 5.3.10 Example: Device + Driver Relationship

```c
// Device initialization
dev->bus = &my_bus_type;
dev->parent = parent;
device_register(dev);

// Driver definition
my_driver = {
    .name = "mydev",
    .bus = &my_bus_type,
    .probe = my_probe,
    ...
};
driver_register(&my_driver);
```

---

### Summary

| Concept                | Summary                                                        |
| ---------------------- | -------------------------------------------------------------- |
| `struct device`        | Represents hardware or virtual device                          |
| `struct device_driver` | Represents the software logic for managing the device          |
| Binding                | Happens via `bus_type->match()` and triggers `driver->probe()` |
| Sysfs                  | Managed via `kobject` in each device                           |
| Refcounting            | Ensures safe creation, usage, and deletion of devices          |

---

Would you like:

* A **sample driver that prints device hierarchy**? (todo)

* To move on to **6.3: Advanced Sysfs and Kobject Manipulation**?


## 5.4 Advanced Sysfs and Kobject Manipulation

---

### 5.4.1 Why Learn This?

* Sysfs provides a **powerful interface** between kernel and userspace.
* It's built on **kobjects**, and understanding how to use them gives you control over:

  * Custom device attributes
  * Dynamically created sysfs files
  * Organizing kernel objects into clean, hierarchical trees

---

### 5.4.2 Quick Recap: kobject

* `kobject` is the base structure for kernel-managed objects.
* It's embedded inside `struct device`, `struct module`, etc.
* It automates **sysfs directory creation**, **reference counting**, and **naming**.

---

### 5.4.3 Where does sysfs come from?

* Created via the kobject inside your device:

```c
/sys/devices/.../          ← device->kobj
/sys/class/.../            ← class->kobj
/sys/bus/.../              ← bus->kobj
```

---

###  5.4.4 Creating Sysfs Attributes for a Device

---

#### Static Way: Use `DEVICE_ATTR` Macros

```c
static ssize_t foo_show(struct device *dev,
                        struct device_attribute *attr, char *buf)
{
    return sprintf(buf, "Hello\n");
}

static ssize_t foo_store(struct device *dev,
                         struct device_attribute *attr,
                         const char *buf, size_t count)
{
    printk(KERN_INFO "Got: %s", buf);
    return count;
}

static DEVICE_ATTR(foo, 0664, foo_show, foo_store);
```

#### Register Attribute in `probe()`:

```c
device_create_file(dev, &dev_attr_foo);
```

#### Unregister in `remove()`:

```c
device_remove_file(dev, &dev_attr_foo);
```

**Result:**

```bash
/sys/devices/.../foo
```

---

###  5.4.5 Dynamically Created Attributes (attr\_group)

For grouping attributes:

```c
static ssize_t mode_show(struct device *dev, struct device_attribute *attr, char *buf)
{
    return sprintf(buf, "mode\n");
}

static DEVICE_ATTR(mode, 0444, mode_show, NULL);

static struct attribute *my_attrs[] = {
    &dev_attr_mode.attr,
    NULL,
};

static struct attribute_group my_attr_group = {
    .attrs = my_attrs,
};

...

// In probe:
sysfs_create_group(&dev->kobj, &my_attr_group);

// In remove:
sysfs_remove_group(&dev->kobj, &my_attr_group);
```

**Sysfs structure becomes:**

```bash
/sys/devices/.../mode
```

You can even create nested attribute groups (`subsys`, `groups`, etc.).

---

### 5.4.6 Custom Kobject + Sysfs (Advanced)

If you don’t have a `struct device`, you can manage sysfs directly via `kobject`.

#### Minimal kobject-based sysfs entry:

```c
#include <linux/kobject.h>
#include <linux/sysfs.h>
#include <linux/init.h>

static struct kobject *example_kobj;

static ssize_t foo_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
{
    return sprintf(buf, "foo value\n");
}

static struct kobj_attribute foo_attr = __ATTR(foo, 0444, foo_show, NULL);

static int __init example_init(void)
{
    example_kobj = kobject_create_and_add("my_kobj", kernel_kobj);
    if (!example_kobj)
        return -ENOMEM;

    return sysfs_create_file(example_kobj, &foo_attr.attr);
}

static void __exit example_exit(void)
{
    sysfs_remove_file(example_kobj, &foo_attr.attr);
    kobject_put(example_kobj);
}

module_init(example_init);
module_exit(example_exit);
MODULE_LICENSE("GPL");
```

**Result:**

```bash
/sys/kernel/my_kobj/foo
```

---

### Good Practices

* Always remove sysfs files/groups during `remove()` or `exit()`.
* Avoid exposing unsafe raw device registers directly to userspace.
* Keep sysfs attributes **small**, **atomic**, and **human-readable**.

---

###  Testing Sysfs Attributes

```bash
# Read attribute
cat /sys/bus/platform/devices/my_device/foo

# Write to attribute
echo "new value" > /sys/bus/platform/devices/my_device/foo
```

Use `strace`, `udevadm`, and `ftrace` to debug if files aren't appearing.

---

### Summary

| Topic                      | Key Takeaway                                       |
| -------------------------- | -------------------------------------------------- |
| `device_create_file()`     | Easiest way to expose sysfs attributes on a device |
| `sysfs_create_group()`     | Cleaner grouping of multiple attributes            |
| `kobject_create_and_add()` | For fully manual sysfs trees (no `struct device`)  |
| Attributes                 | Should be readable, atomic, and kernel-safe        |

---

Would you like to:

* See a **complete sample driver with multiple sysfs groups**?
* Move on to **6.4: Reference Counting and Lifetime Management**?


## 5.5 Reference Counting & Lifetime Management

---

### 5.5.1 Why it matters:

In the Linux device model, **objects (devices, drivers, kobjects)** must only be destroyed **when they're no longer in use**.
The kernel uses **reference counting** to safely track and control object lifetimes.

---

### 5.5.2 Objects with Refcounting

Most core structures embed a reference counter (either `kref` or `kobject`):

| Structure              | Refcount Mechanism                  |
| ---------------------- | ----------------------------------- |
| `struct device`        | Via `kobject`                       |
| `struct device_driver` | Via `kobject`                       |
| `struct kobject`       | Via `kref`                          |
| `struct module`        | Via `module_get()` / `module_put()` |

---

### 5.5.3 Core APIs for Managing Device Lifetimes

| Function                 | Description                                  |
| ------------------------ | -------------------------------------------- |
| `get_device(dev)`        | Increment device reference count             |
| `put_device(dev)`        | Decrement reference count, possibly free     |
| `device_register(dev)`   | Calls `device_initialize()` + `device_add()` |
| `device_unregister(dev)` | Calls `put_device()` and may destroy `dev`   |
| `get_driver(drv)`        | Increment refcount of driver                 |
| `put_driver(drv)`        | Decrement and possibly release               |
| `kobject_get(kobj)`      | Generic object refcounting                   |
| `kobject_put(kobj)`      | Safe object destruction                      |

---

### 5.5.4 How `kobject` and `kref` Work

* `kobject` includes an internal `kref` counter.
* When the refcount hits **zero**, the release function is called.

#### Simplified View:

```c
struct kobject {
    struct kref kref;
    void (*release)(struct kobject *);
    ...
};
```

---

####  Reference Flow for `struct device`

```c
struct device *dev = kmalloc(sizeof(*dev), GFP_KERNEL);
device_initialize(dev);        // Initializes kobject and sets refcount = 1

get_device(dev);               // refcount++
put_device(dev);               // refcount--

device_register(dev);          // Adds device to model
device_unregister(dev);        // Removes + put_device()
```

---

### 5.5.5 Example: Using `get_device()` / `put_device()`

```c
static void do_something_with_device(struct device *dev)
{
    if (!get_device(dev)) {
        printk(KERN_WARNING "Device is gone\n");
        return;
    }

    // Safe to use device
    ...

    put_device(dev);
}
```

This is essential when you're **storing pointers** or using devices in delayed contexts (e.g., workqueues, IRQs).

---

### 5.5.6 If You Don't Use Refcounting...

| Problem        | Consequence              |
| -------------- | ------------------------ |
| Use after free | Crash, security bug      |
| Double free    | Kernel panic             |
| Memory leak    | Forgotten `put_device()` |

---

### 5.5.7 Custom Release Function

You must provide a release function to clean up device memory:

```c
void my_device_release(struct device *dev)
{
    printk(KERN_INFO "Releasing my device\n");
    kfree(dev);
}

...

// In your init code:
dev->release = my_device_release;
```

Without a release function, the kernel **warns** and **leaks memory**.

---

### 5.5.8 Driver Lifetime & Module Use Count

To prevent unloading an in-use module:

```c
if (!try_module_get(dev->driver->owner)) {
    // Can't use the driver
}
...
module_put(dev->driver->owner);
```

This prevents kernel from unloading a module while it's still in use by a device.

---

### 5.5.9  Tools to Debug Lifetime Issues

* `kmemleak`: Detect unfreed memory in kernel
* `ftrace` / `kprobes`: Trace device reference paths
* `printk()` + `dev_dbg()` logging

---

## Summary

| Topic                           | Key Takeaways                         |
| ------------------------------- | ------------------------------------- |
| `get_device()` / `put_device()` | Manage device lifetime safely         |
| `kobject` / `kref`              | Underlying refcounting mechanism      |
| `release()`                     | Mandatory for dynamic `struct device` |
| Lifetime bugs                   | Can cause crashes or memory leaks     |

---

Would you like:

* A **full example driver using `get_device()` with delayed work**?
* Or continue to **6.5: Dynamic Device Creation and Hotplugging**?

--------------

