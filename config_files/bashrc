# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples

# If not running interactively, don't do anything
case $- in
    *i*) ;;
      *) return;;
esac

# don't put duplicate lines or lines starting with space in the history.
# See bash(1) for more options
HISTCONTROL=ignoreboth

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=1000
HISTFILESIZE=2000

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# If set, the pattern "**" used in a pathname expansion context will
# match all files and zero or more directories and subdirectories.
#shopt -s globstar

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm-color|*-256color) color_prompt=yes;;
esac

# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
#force_color_prompt=yes

if [ -n "$force_color_prompt" ]; then
    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
	# We have color support; assume it's compliant with Ecma-48
	# (ISO/IEC-6429). (Lack of such support is extremely rare, and such
	# a case would tend to support setf rather than setaf.)
	color_prompt=yes
    else
	color_prompt=
    fi
fi

if [ "$color_prompt" = yes ]; then
    PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
else
    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
fi
unset color_prompt force_color_prompt

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm*|rxvt*)
    PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
    ;;
*)
    ;;
esac

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    #alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

Color_Off="\[\033[0m\]"       # Text Reset

    # Regular Colors
    Black="\[\033[0;30m\]"        # Black
    Red="\[\033[0;31m\]"          # Red
    Green="\[\033[0;32m\]"        # Green
    Yellow="\[\033[0;33m\]"       # Yellow
    Blue="\[\033[0;34m\]"         # Blue
    Purple="\[\033[0;35m\]"       # Purple
    Cyan="\[\033[0;36m\]"         # Cyan
    White="\[\033[0;37m\]"        # White

    # Bold
    BBlack="\[\033[1;30m\]"       # Black
    BRed="\[\033[1;31m\]"         # Red
    BGreen="\[\033[1;32m\]"       # Green
    BYellow="\[\033[1;33m\]"      # Yellow
    BBlue="\[\033[1;34m\]"        # Blue
    BPurple="\[\033[1;35m\]"      # Purple
    BCyan="\[\033[1;36m\]"        # Cyan
    BWhite="\[\033[1;37m\]"       # White

    # Underline
    UBlack="\[\033[4;30m\]"       # Black
    URed="\[\033[4;31m\]"         # Red
    UGreen="\[\033[4;32m\]"       # Green
    UYellow="\[\033[4;33m\]"      # Yellow
    UBlue="\[\033[4;34m\]"        # Blue
    UPurple="\[\033[4;35m\]"      # Purple
    UCyan="\[\033[4;36m\]"        # Cyan
    UWhite="\[\033[4;37m\]"       # White

    # Background
    On_Black="\[\033[40m\]"       # Black
    On_Red="\[\033[41m\]"         # Red
    On_Green="\[\033[42m\]"       # Green
    On_Yellow="\[\033[43m\]"      # Yellow
    On_Blue="\[\033[44m\]"        # Blue
    On_Purple="\[\033[45m\]"      # Purple
    On_Cyan="\[\033[46m\]"        # Cyan
    On_White="\[\033[47m\]"       # White

    # High Intensty
    IBlack="\[\033[0;90m\]"       # Black
    IRed="\[\033[0;91m\]"         # Red
    IGreen="\[\033[0;92m\]"       # Green
    IYellow="\[\033[0;93m\]"      # Yellow
    IBlue="\[\033[0;94m\]"        # Blue
    IPurple="\[\033[0;95m\]"      # Purple
    ICyan="\[\033[0;96m\]"        # Cyan
    IWhite="\[\033[0;97m\]"       # White

    # Bold High Intensty
    BIBlack="\[\033[1;90m\]"      # Black
    BIRed="\[\033[1;91m\]"        # Red
    BIGreen="\[\033[1;92m\]"      # Green
    BIYellow="\[\033[1;93m\]"     # Yellow
    BIBlue="\[\033[1;94m\]"       # Blue
    BIPurple="\[\033[1;95m\]"     # Purple
    BICyan="\[\033[1;96m\]"       # Cyan
    BIWhite="\[\033[1;97m\]"      # White

    # High Intensty backgrounds
    On_IBlack="\[\033[0;100m\]"   # Black
    On_IRed="\[\033[0;101m\]"     # Red
    On_IGreen="\[\033[0;102m\]"   # Green
    On_IYellow="\[\033[0;103m\]"  # Yellow
    On_IBlue="\[\033[0;104m\]"    # Blue
    On_IPurple="\[\033[10;95m\]"  # Purple
    On_ICyan="\[\033[0;106m\]"    # Cyan
    On_IWhite="\[\033[0;107m\]"   # White

# colored GCC warnings and errors
#export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'

# some more ls aliases
alias ll='ls -alF'
alias la='ls -A'
#alias l='ls -CF'
alias l='ls -qalt'

# Add an "alert" alias for long running commands.  Use like so:
#   sleep 10; alert
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'

# Alias definitions.
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.

if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
  fi
fi


GOPATH=/usr/bin

function _update_ps1() {
    #PS1="$($GOPATH/powerline-go -error $? -newline)"
    PS1="$($GOPATH/powerline-go -git-mode simple -error $? -cwd-mode plain -hostname-only-if-ssh -newline -condensed)"
}

#if [ "$TERM" != "linux" ] && [ -f "$GOPATH/bin/powerline-go" ]; then
####if [ "$TERM" != "linux" ] ; then
# for some reason the _update_ps1() function could not be called to update the prompt
# exporting PROMPT_COMMAND solves the issue
#PROMPT_COMMAND="_update_ps1; \$PROMPT_COMMAND"
####	export PROMPT_COMMAND="_update_ps1; $PROMPT_COMMAND"

	#PS1="$($GOPATH/powerline-go -error $?)"
####fi

export PATH=$PATH:/home/daybreak/.local/bin:/home/daybreak/bin

#. ~/bin/git-prompt.sh

alias buildServer="ssh pulumati@buildserver"
alias bS2="ssh pulumati@172.21.177.97 -p 10021"
alias nuc="ssh daybian@10.10.10.1 -X"
alias piServer="ssh pi@chakra"
alias ffmpeg="ffmpeg -hide_banner "
alias ffprobe="ffprobe -hide_banner"

#--- GIT Related ---
# Plugin for bash if Not using powerline-go
# wget https://raw.githubusercontent.com/git/git/master/contrib/completion/git-prompt.sh -O .gitprompt
#chmod 755 .gitprompt
. ~/.gitprompt

#Autocomplete git commands 
#wget https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash -O .gitcompletion
#chmod 755 .gitcompletion
. ~/.gitcompletion

# mc editor set to vim as default ( DISABLE: mc>options>configuration>'use internal editor' and save )
export VISUAL=vim; export EDITOR="$VISUAL"

function weather_graph() {
    if [ -f /tmp/weatherGraph ];then
        # disable weather after first update
        ls -l /tmp/weatherGraph
        ###cat /tmp/weatherGraph
    else
        curl  wttr.in/hsinchu?format=v2 2> /dev/null|(head -21;tail -14)|head -33 > /tmp/weatherGraph
        # disable weather after first update
        ls -l /tmp/weatherGraph
        ###cat /tmp/weatherGraph
    fi
}
function weather() {
    if [ -f /tmp/weather ];then
        ls -l /tmp/weather
        # disable weather after first update
        # cat /tmp/weather
    else
        curl  wttr.in/hsinchu |head -39 > /tmp/weather
        ls -l /tmp/weather
        # disable weather after first update
        #cat /tmp/weather
    fi
}
function showWeather()
{
if [ $COLUMNS -lt 125 ]
then
 #curl wttr.in/hsinchu?2n
 #curl  wttr.in/hsinchu?format=v2 2> /dev/null|(head -21;tail -14)|head -33
 weather_graph
else
 #curl wttr.in/hsinchu
 weather
fi
}
###showWeather

function navigation(){
    echo "Navigation
    Ctrl + a    :    Go to the beginning of the line.
    Ctrl + e 	:    Go to the end of the line.
    Alt + f 	:    Move the cursor forward one word.
    Alt + b 	:    Move the cursor back one word.
    Ctrl + f 	:    Move the cursor forward one character.
    Ctrl + b 	:    Move the cursor back one character.
    Ctrl + x, x :    Toggle between the current cursor position and the beginning of the line."
}
function editing(){
    echo "Editing
    Ctrl + _ 	       :    Undo! (And, yes, that's an underscore, so you'll probably need to use Shift as well.)
    Ctrl + x, Ctrl + e :    Edit the current command in your $EDITOR.
    Alt + d 	       :    Delete the word after the cursor.
    Alt + Delete       :    Delete the word before the cursor.
    Ctrl + d           :    Delete the character beneath the cursor.
    Ctrl + h           :    Delete the character before the cursor (like backspace).
    Ctrl + k           :    Cut the line after the cursor to the clipboard.
    Ctrl + u           :    Cut the line before the cursor to the clipboard.
    Ctrl + d           :    Cut the word after the cursor to the clipboard.
    Ctrl + w           :    Cut the word before the cursor to the clipboard.
    Ctrl + y           :    Paste the last item to be cut."
}
function process(){
    echo "Processes
    Ctrl + l 	:    Clear the entire screen (like the clear command).
    Ctrl + z 	:    Place the currently running process into a suspended background process (and then use fg to restore).
    Ctrl + c 	:    Kill the currently running process by sending the SIGINT signal.
    Ctrl + d 	:    Exit the current shell.
    Enter, ~, . :    Exit a stalled SSH session."
}
function history() {
    echo "History 	
    Ctrl + r 	:    Bring up the history search.
    Ctrl + g 	:    Exit the history search.
    Ctrl + p 	:    See the previous command in the history.
    Ctrl + n 	:    See the next command in the history."
}

alias Minicom="sudo minicom -b 460800"
alias scream_teams="/usr/libexec/mate-notification-daemon -r &"

gen_prompt() {
    ## Looks like:
    ## ╭─┤pty0├─╢mark@bender:~/src╟─┤(✿◠‿◠)├─╮
    ## ╰>
    local __last_exit=$?
    [[ -f ~/.colors ]] && source ~/.colors

    local __line_color=${BGreen}
    local __prompt_color=${White}
    local __text_color=${White}
    local __text_sodium=${BYellow}

    local __success_string="${Green}(${Yellow}✿${Green}◠‿◠)"
    local __failure_string="${Red}(◡﹏◡✿)"
    local __exit_string=$(if [[ $__last_exit -ne 0 ]]; then echo $__failure_string; else echo $__success_string; fi)
    #local __prompt="> "
    local __prompt=" "

    ####PS1="\n${__line_color}╭─┤${__text_color}\l${__line_color}├─╢${__text_color}\u@\h:\w${__line_color}╟─┤${__exit_string}${__line_color}├─╮\n╰${__prompt}\[$(tput sgr0)\]"
    ###PS1="\n${__line_color}╭─|${__text_color} \l${__line_color} | ${__text_sodium} \t : \w${__line_color} | ${__exit_string}${__line_color}|─╮\n╰${__prompt}\[$(tput sgr0)\]"
    PS1="\n${__line_color}╭─| $($GOPATH/powerline-go -git-mode simple -error $? -cwd-mode plain -hostname-only-if-ssh -newline -condensed)${__prompt}\[$(tput sgr0)\]"
}
####export PROMPT_COMMAND=gen_prompt   #moving from powerline-go to starship..

#alias yt-dlp-playlist='yt-dlp -o "%(playlist_index)s-%(title)s.%(ext)s" '

#starship console
eval "$(starship init bash)"
function _update_ps1() {
    PS1="$(powerline-go -cwd-mode plain -error $? -jobs $(jobs -p | wc -l) -newline -condensed)"
                     
    # Uncomment the following line to automatically clear errors after showing
    # them once. This not only clears the error for powerline-go, but also for
    # everything else you run in that shell. Don't enable this if you're not
    # sure this is what you want.
                     
    #set "?"         
}    
#if [ "$TERM" != "linux" ] ; then
#    PROMPT_COMMAND="_update_ps1; $PROMPT_COMMAND"
#fi

##nvim shotcut
alias nv="nvim"
alias nv-qt="nvim-qt"
. "$HOME/.cargo/env"
alias mountBuildServer="sudo sshfs -o allow_other,IdentityFile=/home/daybreak/.ssh/id_rsa pulumati@172.21.177.105:/home/pulumati /mnt/WFH/"


alias tmuxSession="tmux new -s  `date +'%b%d'`"
alias gone="git log --oneline"
alias Vi="nvim "
alias nq="nvim-qt "

##LS_COLORS='rs=0:di=1;33:ln=01;36:mh=00:pi=40;33:so=01;33:do=01;33:bd=40;33;01:cd=40;33;01:or=40;31;01:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lz=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.jpg=01;33:*.jpeg=01;33:*.gif=01;33:*.bmp=01;33:*.pbm=01;33:*.pgm=01;33:*.ppm=01;33:*.tga=01;33:*.xbm=01;33:*.xpm=01;33:*.tif=01;33:*.tiff=01;33:*.png=01;33:*.svg=01;33:*.svgz=01;33:*.mng=01;33:*.pcx=01;33:*.mov=01;33:*.mpg=01;33:*.mpeg=01;33:*.m2v=01;33:*.mkv=01;33:*.webm=01;33:*.ogm=01;33:*.mp4=01;33:*.m4v=01;33:*.mp4v=01;33:*.vob=01;33:*.qt=01;33:*.nuv=01;33:*.wmv=01;33:*.asf=01;33:*.rm=01;33:*.rmvb=01;33:*.flc=01;33:*.avi=01;33:*.fli=01;33:*.flv=01;33:*.gl=01;33:*.dl=01;33:*.xcf=01;33:*.xwd=01;33:*.yuv=01;33:*.cgm=01;33:*.emf=01;33:*.axv=01;33:*.anx=01;33:*.ogv=01;33:*.ogx=01;33:*.aac=00;36:*.au=00;36:*.flac=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.axa=00;36:*.oga=00;36:*.spx=00;36:*.xspf=00;36:';export LS_COLORS 
# STR="make --always-make --dry-run \
#  | grep -wE 'gcc|g\+\+' \
#  | grep -w '\-c' \
#  | jq -nR '[inputs|{directory:".", command:., file: match(" [^ ]+$").string[1:]}]' \
#  > compile_commands.json"
# alias  compile_commands_json="echo $STR"

TMPIDX=`shuf -i 0-4 -n1`
helpFuns=("navigation" "editing" "process" "history" )
##showWeather
# disable 
### ${helpFuns[$TMPIDX]}

alias ssh-yocto="ssh  root@10.10.10.27"

##NVIM_QT_RUNTIME_PATH=/home/daybreak/packages/neovim-qt/src/gui/runtime  ~/bin/nvim-qt
alias nqt="NVIM_QT_RUNTIME_PATH=/home/daybreak/packages/neovim-qt/src/gui/runtime  ~/bin/nvim-qt"
export EDITOR=nvim

function show_wez_banner()
{
    if [ $WEZTERM_EXECUTABLE  ]
    then
        sleep 1
        wezterm-bak imgcat /home/daybreak/Pictures/rust-logos/rust-bio.png 
    fi
}
#show_wez_banner

alias rustdoc="qutebrowser ~/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/share/doc/rust/html/book/index.html & "

# make folders first show filenames along with path for nb list command
alias nbb="nb -f --filenames --path"
alias wget-ms="wget --user-agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36 Edg/124.0.0.0'"  
alias wezterm='flatpak run org.wezfurlong.wezterm'
alias ip10="sudo ip a a 10.10.10.10/24 dev enp3s0"
# intialize zoxide before using
eval "$(zoxide init bash)"
#alias z="zoxide"
export PATH="$HOME/.npm-global/bin:$PATH"
